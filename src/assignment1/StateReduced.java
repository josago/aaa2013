package assignment1;

import java.util.Iterator;

/**
 * This class implements a state space in which states are only encoded by the distance between prey and predator, and not by their coordinates.
 * This greatly reduces the state space from 11^4 different states to only 11^2.
 * @author josago
 */
public class StateReduced extends StateSimple
{
	private int distanceX, distanceY;
	
	public StateReduced(int predatorX, int predatorY, int preyX, int preyY)
	{
		super(predatorX, predatorY, preyX, preyY); // The coordinates are internally preserved for a correct behaviour when printing the board.
		
		calculateDistances();
	}
	
	@Override
	public Iterator<State> stateIterator()
	{
		class IteratorStates implements Iterator<State>
		{
			private boolean hasNext;
			
			private int x, y;
			
			public IteratorStates()
			{
				hasNext = true;
				
				x = 0;
				y = 0;
			}
			
			@Override
			public boolean hasNext()
			{
				return hasNext;
			}

			@Override
			public State next()
			{
				State nextState = new StateReduced(x, y, 5, 5);
				
				x++;
				
				if (x == ENVIRONMENT_SIZE)
				{
					x = 0;
					
					y++;
					
					if (y == ENVIRONMENT_SIZE)
					{
						hasNext = false;
					}
				}
				
				return nextState;
			}

			@Override
			public void remove()
			{
				// TODO Auto-generated method stub
			}
		}
		
		return new IteratorStates();
	}
	
	@Override
	public void move(Agent agent)
	{
		super.move(agent);
		
		calculateDistances();
	}
	
	@Override
	public Object clone()
	{
		return new StateReduced(x[Agent.TYPE_PREDATOR], y[Agent.TYPE_PREDATOR], x[Agent.TYPE_PREY], y[Agent.TYPE_PREY]);
	}
	
	private void calculateDistances()
	{
		int distX1 = x[Agent.TYPE_PREY] - x[Agent.TYPE_PREDATOR];
		int distX2;
		
		if (distX1 < 0)
		{
			distX2 = distX1 + ENVIRONMENT_SIZE;
		}
		else
		{
			distX2 = distX1 - ENVIRONMENT_SIZE;
		}
		
		if (Math.abs(distX1) < Math.abs(distX2))
		{
			distanceX = distX1;
		}
		else
		{
			distanceX = distX2;
		}
		
		int distY1 = y[Agent.TYPE_PREY] - y[Agent.TYPE_PREDATOR];
		int distY2;
		
		if (distY1 < 0)
		{
			distY2 = distY1 + ENVIRONMENT_SIZE;
		}
		else
		{
			distY2 = distY1 - ENVIRONMENT_SIZE;
		}
		
		if (Math.abs(distY1) < Math.abs(distY2))
		{
			distanceY = distY1;
		}
		else
		{
			distanceY = distY2;
		}	
	}
	
	// Automatically-generated by Eclipse:

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + distanceX;
		result = prime * result + distanceY;
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		StateReduced other = (StateReduced) obj;
		if (distanceX != other.distanceX)
			return false;
		if (distanceY != other.distanceY)
			return false;
		return true;
	}
}
